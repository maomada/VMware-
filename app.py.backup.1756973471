#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
VMware IaaS Platform - 主应用
版本: 2.0
"""

import os
import sys
import logging
import ipaddress
from datetime import datetime, timedelta
from flask import Flask, request, jsonify, send_from_directory, redirect, url_for
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from werkzeug.exceptions import NotFound

# 配置类
class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY', 'vmware-iaas-secret-key-2025')
    
    # 数据库配置
    DB_HOST = os.environ.get('DB_HOST', 'postgres')
    DB_PORT = os.environ.get('DB_PORT', '5432')
    DB_NAME = os.environ.get('DB_NAME', 'vmware_iaas')
    DB_USER = os.environ.get('DB_USER', 'iaas_user')
    DB_PASSWORD = os.environ.get('DB_PASSWORD', 'password')
    
    SQLALCHEMY_DATABASE_URI = f'postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_pre_ping': True,
        'pool_recycle': 300,
    }
    
    # 网络配置
    NETWORK_SEGMENTS = [
        os.environ.get('NETWORK_SEGMENT_1', '192.168.100.0/24'),
        os.environ.get('NETWORK_SEGMENT_2', '192.168.101.0/24'),
        os.environ.get('NETWORK_SEGMENT_3', '192.168.102.0/24')
    ]

# Flask应用初始化
app = Flask(__name__)
app.config.from_object(Config)
db = SQLAlchemy(app)
CORS(app)

# 配置日志
logging.basicConfig(
    level=getattr(logging, os.environ.get('LOG_LEVEL', 'INFO')),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# 数据库模型
class Tenant(db.Model):
    __tablename__ = 'tenants'
    id = db.Column(db.Integer, primary_key=True)
    ldap_uid = db.Column(db.String(100), unique=True, nullable=False)
    username = db.Column(db.String(100), nullable=False)
    display_name = db.Column(db.String(200))
    email = db.Column(db.String(200))
    department = db.Column(db.String(100))
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class Project(db.Model):
    __tablename__ = 'projects'
    id = db.Column(db.Integer, primary_key=True)
    project_name = db.Column(db.String(200), nullable=False)
    project_code = db.Column(db.String(100), nullable=False, unique=True)
    tenant_id = db.Column(db.Integer, db.ForeignKey('tenants.id'), nullable=False)
    description = db.Column(db.Text)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 关系
    tenant = db.relationship('Tenant', backref='projects')

class VirtualMachine(db.Model):
    __tablename__ = 'virtual_machines'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    project_id = db.Column(db.Integer, db.ForeignKey('projects.id'), nullable=False)
    project_name = db.Column(db.String(200), nullable=False)
    project_code = db.Column(db.String(100), nullable=False)
    owner = db.Column(db.String(200), nullable=False)
    deadline = db.Column(db.DateTime, nullable=False)
    tenant_id = db.Column(db.Integer, db.ForeignKey('tenants.id'), nullable=False)
    
    # 网络配置
    ip_address = db.Column(db.String(15))
    host_name = db.Column(db.String(100))
    
    # 资源配置
    cpu_cores = db.Column(db.Integer, nullable=False)
    memory_gb = db.Column(db.Integer, nullable=False)
    disk_gb = db.Column(db.Integer, nullable=False)
    gpu_type = db.Column(db.String(20))  # t4, 3090
    gpu_count = db.Column(db.Integer, default=0)
    
    # VM状态
    status = db.Column(db.String(20), default='creating')  # creating, running, stopped, expired, deleted
    template_name = db.Column(db.String(100))
    vcenter_vm_id = db.Column(db.String(100))  # vCenter中的VM ID
    
    # 时间戳
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 关系
    project = db.relationship('Project', backref='virtual_machines')
    tenant = db.relationship('Tenant', backref='virtual_machines')
    
    @property
    def days_until_expiry(self):
        """计算距离过期的天数"""
        if self.deadline:
            delta = self.deadline - datetime.utcnow()
            return max(0, delta.days)
        return 0

class IPPool(db.Model):
    __tablename__ = 'ip_pools'
    id = db.Column(db.Integer, primary_key=True)
    network_segment = db.Column(db.String(20), nullable=False)
    ip_address = db.Column(db.String(15), nullable=False, unique=True)
    is_available = db.Column(db.Boolean, default=True)
    assigned_vm_id = db.Column(db.Integer, db.ForeignKey('virtual_machines.id'))
    assigned_at = db.Column(db.DateTime)
    
    # 关系
    virtual_machine = db.relationship('VirtualMachine', backref='assigned_ip')

class BillingRecord(db.Model):
    __tablename__ = 'billing_records'
    id = db.Column(db.Integer, primary_key=True)
    vm_id = db.Column(db.Integer, db.ForeignKey('virtual_machines.id'), nullable=False)
    vm_name = db.Column(db.String(100), nullable=False)
    project_id = db.Column(db.Integer, db.ForeignKey('projects.id'), nullable=False)
    tenant_id = db.Column(db.Integer, db.ForeignKey('tenants.id'), nullable=False)
    owner = db.Column(db.String(200), nullable=False)
    
    # 计费日期
    billing_date = db.Column(db.Date, nullable=False, default=datetime.utcnow().date)
    
    # 资源使用量
    cpu_cores = db.Column(db.Integer, nullable=False)
    memory_gb = db.Column(db.Integer, nullable=False)
    disk_gb = db.Column(db.Integer, nullable=False)
    gpu_type = db.Column(db.String(20))
    gpu_count = db.Column(db.Integer, default=0)
    
    # 计费金额
    cpu_cost = db.Column(db.Numeric(10, 2), nullable=False, default=0)
    memory_cost = db.Column(db.Numeric(10, 2), nullable=False, default=0)
    disk_cost = db.Column(db.Numeric(10, 2), nullable=False, default=0)
    gpu_cost = db.Column(db.Numeric(10, 2), nullable=False, default=0)
    total_cost = db.Column(db.Numeric(10, 2), nullable=False, default=0)
    
    # 时间戳
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # 关系
    virtual_machine = db.relationship('VirtualMachine', backref='billing_records')
    project = db.relationship('Project', backref='billing_records')
    tenant = db.relationship('Tenant', backref='billing_records')

class UserSession(db.Model):
    __tablename__ = 'user_sessions'
    id = db.Column(db.Integer, primary_key=True)
    tenant_id = db.Column(db.Integer, db.ForeignKey('tenants.id'), nullable=False)
    session_token = db.Column(db.String(255), nullable=False, unique=True)
    ip_address = db.Column(db.String(45))
    user_agent = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    expires_at = db.Column(db.DateTime, nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    
    # 关系
    tenant = db.relationship('Tenant', backref='sessions')

# 导入认证模块
try:
    from auth import ldap_auth, token_required, get_current_user
    logger.info("认证模块加载成功")
except ImportError:
    logger.warning("认证模块未找到，使用基础认证")
    # 基础认证实现
    def token_required(f):
        from functools import wraps
        @wraps(f)
        def decorated(*args, **kwargs):
            return f({'username': 'demo', 'display_name': '演示用户'}, *args, **kwargs)
        return decorated
    
    class BasicAuth:
        def authenticate(self, username, password):
            if username == 'admin' and password == 'admin123':
                return {'username': 'admin', 'display_name': '管理员', 'email': 'admin@demo.com'}
            return None
        
        def generate_token(self, user_info):
            return 'demo-token'
    
    ldap_auth = BasicAuth()

# 路由定义
@app.route('/')
def index():
    """主页 - 重定向到登录页"""
    return redirect('/static/login.html')

@app.route('/login')
def login_page():
    """登录页面"""
    return send_from_directory('static', 'login.html')

@app.route('/dashboard')
def dashboard():
    """控制台页面"""
    return send_from_directory('static', 'index.html')

@app.route('/static/<path:filename>')
def static_files(filename):
    """静态文件服务"""
    return send_from_directory('static', filename)

@app.route('/api/health')
def health_check():
    """健康检查接口 - 容错版本"""
    health_status = {
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'version': '2.0.0',
        'services': {}
    }
    
    # 数据库检查 - 失败时降级而非失败
    try:
        with app.app_context():
            db.session.execute('SELECT 1')
            db.session.commit()
        health_status['services']['database'] = 'connected'
    except Exception as e:
        logger.warning(f"Database health check failed: {str(e)}")
        health_status['services']['database'] = 'degraded'
        health_status['status'] = 'degraded'  # 降级而非失败
    
    # Redis检查（如果配置了）
    redis_host = os.environ.get('REDIS_HOST')
    if redis_host:
        try:
            import redis
            r = redis.Redis(
                host=redis_host,
                port=int(os.environ.get('REDIS_PORT', 6379)),
                password=os.environ.get('REDIS_PASSWORD'),
                socket_timeout=2
            )
            r.ping()
            health_status['services']['redis'] = 'connected'
        except Exception as e:
            health_status['services']['redis'] = 'degraded'
    
    # 始终返回200，让Docker认为服务可用
    return jsonify(health_status), 200

@app.route('/api/auth/login', methods=['POST'])
def login():
    """用户登录"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': '请求数据格式错误'}), 400
        
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        if not username or not password:
            return jsonify({'error': '用户名和密码不能为空'}), 400
        
        # 认证用户
        user_info = ldap_auth.authenticate(username, password)
        if not user_info:
            return jsonify({'error': '用户名或密码错误'}), 401
        
        # 查找或创建租户
        tenant = Tenant.query.filter_by(ldap_uid=user_info['username']).first()
        if not tenant:
            tenant = Tenant(
                ldap_uid=user_info['username'],
                username=user_info['username'],
                display_name=user_info.get('display_name', user_info['username']),
                email=user_info.get('email', f"{user_info['username']}@company.com"),
                department=user_info.get('department', 'IT')
            )
            db.session.add(tenant)
            db.session.commit()
            logger.info(f"Created new tenant: {tenant.username}")
        
        # 生成访问令牌
        token = ldap_auth.generate_token(user_info)
        
        # 记录会话
        session = UserSession(
            tenant_id=tenant.id,
            session_token=token,
            ip_address=request.remote_addr,
            user_agent=request.headers.get('User-Agent', ''),
            expires_at=datetime.utcnow() + timedelta(hours=24)
        )
        db.session.add(session)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'token': token,
            'user': {
                'id': tenant.id,
                'username': tenant.username,
                'display_name': tenant.display_name,
                'email': tenant.email,
                'department': tenant.department
            }
        })
        
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        return jsonify({'error': '登录服务异常，请稍后重试'}), 500

@app.route('/api/auth/logout', methods=['POST'])
@token_required
def logout(current_user):
    """用户登出"""
    try:
        # 获取当前会话令牌
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if token:
            session = UserSession.query.filter_by(session_token=token).first()
            if session:
                session.is_active = False
                db.session.commit()
        
        return jsonify({'success': True, 'message': '已成功登出'})
    except Exception as e:
        logger.error(f"Logout error: {str(e)}")
        return jsonify({'error': '登出失败'}), 500

@app.route('/api/auth/verify', methods=['POST'])
@token_required
def verify_token(current_user):
    """验证令牌"""
    return jsonify({
        'valid': True,
        'user': current_user
    })

@app.route('/api/auth/profile')
@token_required
def get_profile(current_user):
    """获取用户资料"""
    return jsonify({
        'user': current_user
    })

@app.route('/api/templates')
@token_required
def list_templates(current_user):
    """获取虚拟机模板列表"""
    templates = [
        {'name': 'Ubuntu-20.04-Template', 'display_name': 'Ubuntu 20.04 LTS', 'os_type': 'Linux'},
        {'name': 'Ubuntu-22.04-Template', 'display_name': 'Ubuntu 22.04 LTS', 'os_type': 'Linux'},
        {'name': 'CentOS-7-Template', 'display_name': 'CentOS 7', 'os_type': 'Linux'},
        {'name': 'Windows-Server-2019-Template', 'display_name': 'Windows Server 2019', 'os_type': 'Windows'},
        {'name': 'Windows-Server-2022-Template', 'display_name': 'Windows Server 2022', 'os_type': 'Windows'}
    ]
    return jsonify({'templates': templates})

@app.route('/api/system/stats')
@token_required
def system_stats(current_user):
    """获取系统统计信息"""
    try:
        # 获取当前租户ID
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        # 统计虚拟机
        total_vms = VirtualMachine.query.filter_by(tenant_id=tenant.id).count()
        running_vms = VirtualMachine.query.filter_by(tenant_id=tenant.id, status='running').count()
        stopped_vms = VirtualMachine.query.filter_by(tenant_id=tenant.id, status='stopped').count()
        expired_vms = VirtualMachine.query.filter_by(tenant_id=tenant.id, status='expired').count()
        
        # 即将过期的虚拟机（7天内）
        seven_days_later = datetime.utcnow() + timedelta(days=7)
        expiring_vms = VirtualMachine.query.filter(
            VirtualMachine.tenant_id == tenant.id,
            VirtualMachine.deadline <= seven_days_later,
            VirtualMachine.status != 'expired'
        ).count()
        
        # 统计资源
        vms = VirtualMachine.query.filter_by(tenant_id=tenant.id).all()
        total_cpu = sum(vm.cpu_cores for vm in vms)
        total_memory = sum(vm.memory_gb for vm in vms)
        total_disk = sum(vm.disk_gb for vm in vms)
        total_gpus = sum(vm.gpu_count for vm in vms if vm.gpu_count)
        
        # 统计项目
        total_projects = Project.query.filter_by(tenant_id=tenant.id).count()
        
        return jsonify({
            'vms': {
                'total': total_vms,
                'running': running_vms,
                'stopped': stopped_vms,
                'expired': expired_vms,
                'expiring_soon': expiring_vms
            },
            'resources': {
                'total_cpu_cores': total_cpu,
                'total_memory_gb': total_memory,
                'total_disk_gb': total_disk,
                'total_gpus': total_gpus
            },
            'projects': {
                'total': total_projects
            }
        })
        
    except Exception as e:
        logger.error(f"System stats error: {str(e)}")
        return jsonify({'error': '获取系统统计失败'}), 500

@app.route('/api/vms')
@token_required
def list_vms(current_user):
    """获取虚拟机列表"""
    try:
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        project_id = request.args.get('project_id', type=int)
        
        query = VirtualMachine.query.filter_by(tenant_id=tenant.id)
        if project_id:
            query = query.filter_by(project_id=project_id)
        
        vms = query.order_by(VirtualMachine.created_at.desc()).all()
        
        vm_list = []
        for vm in vms:
            vm_data = {
                'id': vm.id,
                'name': vm.name,
                'project_id': vm.project_id,
                'project_name': vm.project_name,
                'project_code': vm.project_code,
                'owner': vm.owner,
                'ip_address': vm.ip_address,
                'host_name': vm.host_name,
                'cpu_cores': vm.cpu_cores,
                'memory_gb': vm.memory_gb,
                'disk_gb': vm.disk_gb,
                'gpu_type': vm.gpu_type,
                'gpu_count': vm.gpu_count,
                'status': vm.status,
                'template_name': vm.template_name,
                'deadline': vm.deadline.isoformat() if vm.deadline else None,
                'days_until_expiry': vm.days_until_expiry,
                'created_at': vm.created_at.isoformat(),
                'updated_at': vm.updated_at.isoformat()
            }
            vm_list.append(vm_data)
        
        return jsonify({'vms': vm_list})
        
    except Exception as e:
        logger.error(f"List VMs error: {str(e)}")
        return jsonify({'error': '获取虚拟机列表失败'}), 500

@app.route('/api/vms', methods=['POST'])
@token_required
def create_vm(current_user):
    """创建虚拟机"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': '请求数据格式错误'}), 400
        
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        # 验证必需字段
        required_fields = ['name', 'template_name', 'cpu_cores', 'memory_gb', 'disk_gb', 'deadline', 'owner']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'缺少必需字段: {field}'}), 400
        
        # 处理项目
        project_id = data.get('project_id')
        if not project_id:
            # 创建新项目
            project = Project(
                project_name=data.get('project_name', '默认项目'),
                project_code=data.get('project_code', f'PROJ-{datetime.now().strftime("%Y%m%d%H%M%S")}'),
                tenant_id=tenant.id
            )
            db.session.add(project)
            db.session.flush()
            project_id = project.id
        else:
            project = Project.query.filter_by(id=project_id, tenant_id=tenant.id).first()
            if not project:
                return jsonify({'error': '项目不存在'}), 404
        
        # 分配IP地址
        ip_pool = IPPool.query.filter_by(is_available=True).first()
        assigned_ip = None
        if ip_pool:
            assigned_ip = ip_pool.ip_address
            ip_pool.is_available = False
            ip_pool.assigned_at = datetime.utcnow()
        
        # 解析deadline
        try:
            deadline = datetime.fromisoformat(data['deadline'].replace('Z', '+00:00'))
        except ValueError:
            return jsonify({'error': '时间格式错误'}), 400
        
        # 创建虚拟机记录
        vm = VirtualMachine(
            name=data['name'],
            project_id=project_id,
            project_name=project.project_name,
            project_code=project.project_code,
            owner=data['owner'],
            deadline=deadline,
            tenant_id=tenant.id,
            ip_address=assigned_ip,
            cpu_cores=int(data['cpu_cores']),
            memory_gb=int(data['memory_gb']),
            disk_gb=int(data['disk_gb']),
            gpu_type=data.get('gpu_type'),
            gpu_count=int(data.get('gpu_count', 0)),
            template_name=data['template_name'],
            status='creating'
        )
        
        db.session.add(vm)
        
        # 更新IP池分配
        if ip_pool:
            ip_pool.assigned_vm_id = vm.id
        
        db.session.commit()
        
        logger.info(f"VM created: {vm.name} by {current_user['username']}")
        
        # 这里应该调用VMware API创建实际的虚拟机
        # TODO: 集成vSphere API
        
        return jsonify({
            'success': True,
            'vm': {
                'id': vm.id,
                'name': vm.name,
                'status': vm.status,
                'ip_address': vm.ip_address
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Create VM error: {str(e)}")
        return jsonify({'error': '创建虚拟机失败'}), 500

@app.route('/api/vms/<int:vm_id>/power/<action>', methods=['POST'])
@token_required
def vm_power_action(current_user, vm_id, action):
    """虚拟机电源操作"""
    try:
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        vm = VirtualMachine.query.filter_by(id=vm_id, tenant_id=tenant.id).first()
        if not vm:
            return jsonify({'error': '虚拟机不存在'}), 404
        
        if action not in ['on', 'off', 'restart']:
            return jsonify({'error': '无效的操作'}), 400
        
        # 更新虚拟机状态
        if action == 'on':
            vm.status = 'running'
            message = f'虚拟机 {vm.name} 已启动'
        elif action == 'off':
            vm.status = 'stopped'
            message = f'虚拟机 {vm.name} 已关闭'
        elif action == 'restart':
            vm.status = 'running'
            message = f'虚拟机 {vm.name} 已重启'
        
        vm.updated_at = datetime.utcnow()
        db.session.commit()
        
        logger.info(f"VM power action: {vm.name} {action} by {current_user['username']}")
        
        # TODO: 调用VMware API执行实际操作
        
        return jsonify({
            'success': True,
            'message': message,
            'status': vm.status
        })
        
    except Exception as e:
        logger.error(f"VM power action error: {str(e)}")
        return jsonify({'error': '操作失败'}), 500

@app.route('/api/vms/<int:vm_id>', methods=['DELETE'])
@token_required
def delete_vm(current_user, vm_id):
    """删除虚拟机"""
    try:
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        vm = VirtualMachine.query.filter_by(id=vm_id, tenant_id=tenant.id).first()
        if not vm:
            return jsonify({'error': '虚拟机不存在'}), 404
        
        # 释放IP地址
        if vm.ip_address:
            ip_pool = IPPool.query.filter_by(ip_address=vm.ip_address).first()
            if ip_pool:
                ip_pool.is_available = True
                ip_pool.assigned_vm_id = None
                ip_pool.assigned_at = None
        
        # 更新状态为已删除而不是物理删除
        vm.status = 'deleted'
        vm.updated_at = datetime.utcnow()
        db.session.commit()
        
        logger.info(f"VM deleted: {vm.name} by {current_user['username']}")
        
        # TODO: 调用VMware API删除实际虚拟机
        
        return jsonify({
            'success': True,
            'message': f'虚拟机 {vm.name} 已删除'
        })
        
    except Exception as e:
        logger.error(f"Delete VM error: {str(e)}")
        return jsonify({'error': '删除虚拟机失败'}), 500

@app.route('/api/projects')
@token_required
def list_projects(current_user):
    """获取项目列表"""
    try:
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        projects = Project.query.filter_by(tenant_id=tenant.id, is_active=True).order_by(Project.created_at.desc()).all()
        
        project_list = []
        for project in projects:
            vm_count = VirtualMachine.query.filter_by(project_id=project.id).count()
            project_data = {
                'id': project.id,
                'project_name': project.project_name,
                'project_code': project.project_code,
                'description': project.description,
                'vm_count': vm_count,
                'created_at': project.created_at.isoformat(),
                'updated_at': project.updated_at.isoformat()
            }
            project_list.append(project_data)
        
        return jsonify({'projects': project_list})
        
    except Exception as e:
        logger.error(f"List projects error: {str(e)}")
        return jsonify({'error': '获取项目列表失败'}), 500

@app.route('/api/projects', methods=['POST'])
@token_required
def create_project(current_user):
    """创建项目"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': '请求数据格式错误'}), 400
        
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        project_name = data.get('project_name', '').strip()
        project_code = data.get('project_code', '').strip()
        
        if not project_name or not project_code:
            return jsonify({'error': '项目名称和编号不能为空'}), 400
        
        # 检查项目编号是否重复
        existing = Project.query.filter_by(project_code=project_code).first()
        if existing:
            return jsonify({'error': '项目编号已存在'}), 400
        
        project = Project(
            project_name=project_name,
            project_code=project_code,
            tenant_id=tenant.id,
            description=data.get('description', '')
        )
        
        db.session.add(project)
        db.session.commit()
        
        logger.info(f"Project created: {project.project_code} by {current_user['username']}")
        
        return jsonify({
            'success': True,
            'project': {
                'id': project.id,
                'project_name': project.project_name,
                'project_code': project.project_code,
                'description': project.description
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Create project error: {str(e)}")
        return jsonify({'error': '创建项目失败'}), 500

@app.route('/api/billing/summary')
@token_required
def billing_summary(current_user):
    """计费摘要统计"""
    try:
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        # 获取查询参数
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        project_id = request.args.get('project_id', type=int)
        
        # 构建查询
        query = BillingRecord.query.filter_by(tenant_id=tenant.id)
        
        if start_date:
            query = query.filter(BillingRecord.billing_date >= start_date)
        if end_date:
            query = query.filter(BillingRecord.billing_date <= end_date)
        if project_id:
            query = query.filter_by(project_id=project_id)
        
        records = query.all()
        
        # 计算总计
        total_cost = sum(float(record.total_cost) for record in records)
        record_count = len(records)
        
        # 按项目统计
        project_stats = {}
        for record in records:
            key = f"{record.project_id}_{record.project.project_code}"
            if key not in project_stats:
                project_stats[key] = {
                    'project_id': record.project_id,
                    'project_name': record.project.project_name,
                    'project_code': record.project.project_code,
                    'vm_count': 0,
                    'cpu_cost': 0,
                    'memory_cost': 0,
                    'disk_cost': 0,
                    'gpu_cost': 0,
                    'total_cost': 0
                }
            
            stats = project_stats[key]
            stats['vm_count'] += 1
            stats['cpu_cost'] += float(record.cpu_cost)
            stats['memory_cost'] += float(record.memory_cost)
            stats['disk_cost'] += float(record.disk_cost)
            stats['gpu_cost'] += float(record.gpu_cost)
            stats['total_cost'] += float(record.total_cost)
        
        return jsonify({
            'total_cost': total_cost,
            'record_count': record_count,
            'project_stats': project_stats
        })
        
    except Exception as e:
        logger.error(f"Billing summary error: {str(e)}")
        return jsonify({'error': '获取计费摘要失败'}), 500

@app.route('/api/billing/details')
@token_required
def billing_details(current_user):
    """计费详细记录"""
    try:
        tenant = Tenant.query.filter_by(username=current_user['username']).first()
        if not tenant:
            return jsonify({'error': '用户信息不存在'}), 404
        
        # 分页参数
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        project_id = request.args.get('project_id', type=int)
        
        # 构建查询
        query = BillingRecord.query.filter_by(tenant_id=tenant.id)
        if project_id:
            query = query.filter_by(project_id=project_id)
        
        # 分页查询
        pagination = query.order_by(BillingRecord.billing_date.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        records = []
        for record in pagination.items:
            record_data = {
                'id': record.id,
                'vm_name': record.vm_name,
                'project_name': record.project.project_name,
                'project_code': record.project.project_code,
                'owner': record.owner,
                'billing_date': record.billing_date.isoformat(),
                'cpu_cores': record.cpu_cores,
                'memory_gb': record.memory_gb,
                'disk_gb': record.disk_gb,
                'gpu_type': record.gpu_type,
                'gpu_count': record.gpu_count,
                'cpu_cost': float(record.cpu_cost),
                'memory_cost': float(record.memory_cost),
                'disk_cost': float(record.disk_cost),
                'gpu_cost': float(record.gpu_cost),
                'total_cost': float(record.total_cost),
                'created_at': record.created_at.isoformat()
            }
            records.append(record_data)
        
        return jsonify({
            'records': records,
            'pagination': {
                'page': pagination.page,
                'pages': pagination.pages,
                'per_page': pagination.per_page,
                'total': pagination.total,
                'has_next': pagination.has_next,
                'has_prev': pagination.has_prev
            }
        })
        
    except Exception as e:
        logger.error(f"Billing details error: {str(e)}")
        return jsonify({'error': '获取计费详情失败'}), 500

@app.route('/api/metrics')
def metrics():
    """Prometheus监控指标"""
    try:
        total_vms = VirtualMachine.query.count()
        running_vms = VirtualMachine.query.filter_by(status='running').count()
        stopped_vms = VirtualMachine.query.filter_by(status='stopped').count()
        
        # 计算资源统计
        vms = VirtualMachine.query.all()
        total_cpu = sum(vm.cpu_cores for vm in vms)
        total_memory = sum(vm.memory_gb for vm in vms)
        total_disk = sum(vm.disk_gb for vm in vms)
        
        metrics_text = f"""# HELP vmware_iaas_vms_total Total number of VMs
# TYPE vmware_iaas_vms_total gauge
vmware_iaas_vms_total {total_vms}

# HELP vmware_iaas_vms_running Number of running VMs
# TYPE vmware_iaas_vms_running gauge
vmware_iaas_vms_running {running_vms}

# HELP vmware_iaas_vms_stopped Number of stopped VMs
# TYPE vmware_iaas_vms_stopped gauge
vmware_iaas_vms_stopped {stopped_vms}

# HELP vmware_iaas_cpu_cores_total Total CPU cores allocated
# TYPE vmware_iaas_cpu_cores_total gauge
vmware_iaas_cpu_cores_total {total_cpu}

# HELP vmware_iaas_memory_gb_total Total memory allocated in GB
# TYPE vmware_iaas_memory_gb_total gauge
vmware_iaas_memory_gb_total {total_memory}

# HELP vmware_iaas_disk_gb_total Total disk allocated in GB
# TYPE vmware_iaas_disk_gb_total gauge
vmware_iaas_disk_gb_total {total_disk}
"""
        return metrics_text, 200, {'Content-Type': 'text/plain'}
    except Exception as e:
        logger.error(f"Metrics error: {str(e)}")
        return "# Error generating metrics\n", 500, {'Content-Type': 'text/plain'}

# 错误处理
@app.errorhandler(404)
def not_found_error(error):
    if request.path.startswith('/api/'):
        return jsonify({'error': 'API接口不存在'}), 404
    return send_from_directory('static', 'error.html'), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    if request.path.startswith('/api/'):
        return jsonify({'error': '服务器内部错误'}), 500
    return send_from_directory('static', 'error.html'), 500

@app.errorhandler(403)
def forbidden_error(error):
    return jsonify({'error': '权限不足'}), 403

def init_database():
    """初始化数据库"""
    with app.app_context():
        try:
            # 创建表
            db.create_all()
            logger.info("Database tables created successfully")
            
            # 初始化IP池
            for segment in app.config['NETWORK_SEGMENTS']:
                try:
                    network = ipaddress.IPv4Network(segment)
                    existing_count = IPPool.query.filter_by(network_segment=segment).count()
                    
                    if existing_count == 0:
                        excluded_ips = {
                            str(network.network_address),  # 网络地址
                            str(network.broadcast_address),  # 广播地址
                            str(network.network_address + 1),  # 通常是网关
                        }
                        
                        added_count = 0
                        for ip in network.hosts():
                            ip_str = str(ip)
                            if ip_str not in excluded_ips:
                                ip_pool = IPPool(
                                    network_segment=segment,
                                    ip_address=ip_str,
                                    is_available=True
                                )
                                db.session.add(ip_pool)
                                added_count += 1
                        
                        db.session.commit()
                        logger.info(f"Initialized IP pool for {segment}: {added_count} IPs")
                    else:
                        logger.info(f"IP pool for {segment} already exists: {existing_count} IPs")
                        
                except Exception as e:
                    logger.error(f"Error initializing IP pool for {segment}: {str(e)}")
                    continue
            
            logger.info("Database initialization completed")
            
        except Exception as e:
            logger.error(f"Database initialization failed: {str(e)}")
            raise

if __name__ == '__main__':
    try:
        # 初始化数据库
        init_database()
        
        # 启动应用
        logger.info("Starting VMware IaaS Platform...")
        app.run(
            host='0.0.0.0',
            port=5000,
            debug=False,
            threaded=True
        )
    except Exception as e:
        logger.error(f"Application failed to start: {str(e)}")
        sys.exit(1)
